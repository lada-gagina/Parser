{
module Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing
open ParseLiteral
open SupportingFunctions
open AST
}

let whitespace     = [ ' ' '\t' '\r' '\n' ]

let null           = "null"
let new            = "new"

let digit          = ['0'-'9']
let int            = digit+

let float          = int '.' int

let apostrophe     = [ ''' ]
let char           = apostrophe [ ^ ''' ]+ apostrophe
				   | apostrophe apostrophe apostrophe

let boolean        = "true" | "false"

let quote          = [ '"' ]  
let string         = quote [ ^ '\n' '"' ]+ quote

let letter         = ['a'-'z' 'A'-'Z' '_']
let identifier     = letter (letter | digit)*

let oSqrBracket    = [ '[' ]
let cSqrBracket    = [ ']' ]

let comma          = [ ',' ]
let oBracket       = [ '(' ]
let cBracket       = [ ')' ]

let exclMark       = [ '!' ]
let plus           = [ '+' ]
let hyphen         = [ '-' ]
let dot            = [ '.' ]
let factor         = [ '*' '/' '%' ]
let compare        = [ '>' '<' ] | ">=" | "<=" | "==" | "!="
let logOr          = "||"
let logAnd         = "&&"

let instanceOf     = "instanceOf"

let oCurBracket    = [ '{' ]
let cCurBracket    = [ '}' ]

 
rule tokenize = parse
| whitespace				{ tokenize lexbuf }
| null                      { NULL (getNullLiteral lexbuf) }
| int       				{ INT (getIntegerLiteral lexbuf) }
| boolean                   { BOOLEAN (getBooleanLiteral lexbuf) }
| char                      { CHAR (getCharLiteral lexbuf) }
| string                    { STRING (getStringLiteral lexbuf) }
| float                     { FLOAT (getFloatLiteral lexbuf) }

| new                       { NEW (getPos lexbuf) }
| instanceOf                { INSTANCE_OF } 

| identifier                { IDENT (getId lexbuf) }

| oSqrBracket               { O_SQR_BRACKET (getPos lexbuf) }
| cSqrBracket               { C_SQR_BRACKET (getPos lexbuf) }

| oBracket                  { O_BRACKET (getPos lexbuf) }
| cBracket                  { C_BRACKET (getPos lexbuf) }
| comma                     { COMMA (getPos lexbuf) } 

| exclMark                  { EXCL_MARK (getPos lexbuf) }
| hyphen                    { HYPHEN (getPos lexbuf) }
| plus                      { PLUS }
| dot                       { DOT }
| factor                    { FACTOR (lexemeToBinaryOperator lexbuf) }
| compare                   { COMPARE (lexemeToBinaryOperator lexbuf) }
| logOr                     { LOG_OR }
| logAnd                    { LOG_AND } 

| oCurBracket               { O_CUR_BRACKET (getPos lexbuf) }
| cCurBracket               { C_CUR_BRACKET (getPos lexbuf) }

| eof						{ END }
